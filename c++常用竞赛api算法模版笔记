头文件iostream iomanip cmath string cctype algorithm
#include bits/stdc++.h 万能头
不定输入
int m;cin >> m;cin.ignore();while(m--){string line;getline(cin, line);stringstream ss(line);int x;while(ss >> x){}}
输出
<<setw(n)右对齐字符宽度n <<left<<setw(n)左对齐宽度n <<fixed<< setprecision(n)保留n位小数
printf%d整数 %.2f浮点数 %s字符串 .1lf四舍五入一位小数 %e科学记数法 %c字符 %b布尔
宽度%8d，左边加空格，负号就是右边加空格 printf("%8.2f",x)8个字符，精度为2个字符
模板
#include <bits/stdc++.h>
using namespace std;
#define endl "\n"
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
#define ll long long
#define ull unsigned long long
#define pb push_back
#define mb emplace_back
#define yes cout<<"YES"<<endl
#define no cout<<"NO"<<endl
const ll mod = 1000000007;
//const ll mod = 998244353;
using vi = vector<int>;
using vl = vector<ll>;
using vd = vector<double>;
using vvi = vector<vector<int>>;
using vvl = vector<vector<ll>>;
using vvvi = vector<vector<vector<int>>>;
using vvvl = vector<vector<vector<ll>>>;
using vpii = vector<pair<int, int>>;
using vpll = vector<pair<ll, ll>>;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
#define go(x) int t; cin >> t; while(t--) x();
template<typename T>
void db(T& x) {cout << x;}
template<typename T>
void db(vector<T>& v){cout << "[";for (auto &x : v) cout << (&x==&v[0]?"":",") << x;cout << "]";}
template<typename T>
void db(vector<vector<T>>& v) {cout << endl;for (auto& i : v) {db(i);cout << endl;}}
template<typename T>
void debug(char* name, T& x) {cout << "debug: " << name << " = ";db(x);cout << endl;}
#define db(x) debug(#x, x)
//sort(a.begin(), a.end(), greater<>());
//sort(all(a), [](vi &a, vi &b) {return a[0] < b[0];});
//priority_queue<int, vi, greater<int>> pq;
//struct cmp {bool operator()(int a, int b) {return a > b;}};
//priority_queue<int, vi, cmp> pq;
//int m;cin >> m;cin.ignore();while(m--){string line;getline(cin, line);stringstream ss(line);int x;while(ss >> x){}}不定输入
//<<setw(n)右对齐字符宽度n <<left<<setw(n)左对齐宽度n <<fixed<< setprecision(n)保留n位小数
ll ksm(ll x, ll n) {
    ll ans = 1;
    while (n > 0) {
        if (n & 1) {
            ans = ans * x % mod;
        }
        x = x * x % mod;
        n >>= 1;
    }
    return ans;
}
ll ny(ll x) {//依赖ksm
    return ksm(x, mod - 2);
}
vi minp, primes;//最小质因数等于自身为质数，小于等于n的全部质数
void initp(int n) {
    minp.assign(n + 1, 0);
    primes.clear();
    for (int i = 2; i <= n; i++) {
        if (minp[i] == 0) {
            minp[i] = i;
            primes.push_back(i);
        }
        for (const int& p : primes) {
            if (i * p > n)break;
            minp[i * p] = p;
            if (p == minp[i])break;
        }
    }
}
vl nyb;
void initny(ll n){//线性求逆元
    nyb.assign(n, 0);
    nyb[1] = 1;
    for (ll i = 2; i < n; ++i) {
        nyb[i] = (mod - (mod / i) * nyb[mod % i] % mod) % mod;
    }
}
vl jcb, jcnyb;
void initjc(ll n) {//依赖ny,ksm
    jcb.assign(n + 1, 1);
    jcnyb.assign(n + 1, 1);
    for (ll i = 1; i <= n; ++i) {
        jcb[i] = jcb[i - 1] * i % mod;
    }
    jcnyb[n] = ny(jcb[n]);
    for (ll i = n - 1; i >= 0; --i) {
        jcnyb[i] = jcnyb[i + 1] * (i + 1) % mod;
    }
}
inline ll C(ll n, ll k) {//依赖initjc
    if (k < 0 || k > n) return 0;
    return jcb[n] * jcnyb[k] % mod * jcnyb[n - k] % mod;
}
inline ll A(ll n, ll k) {//依赖initjc
    if (k < 0 || k > n) return 0;
    return jcb[n] * jcnyb[n - k] % mod;
}
int find(vi& root, int x) {//并查集简洁写法
    if (root[x] == x)return x;
    return root[x] = find(root, root[x]);
}
struct Trie {//常数较大
    struct Node {
        int next[26];int cnt;
        Node() {
            memset(next, 0, sizeof(next));
            cnt = 0;
        }
    };
    vector<Node> nodes;
    Trie() {
        nodes.mb();
    }
    void insert(const string& word) {
        int i = 0;
        for (char c : word) {
            c -= 'a';
            if (nodes[i].next[c] == 0) {
                nodes[i].next[c] = nodes.size();
                nodes.mb();
            }
            i = nodes[i].next[c];
            nodes[i].cnt++;
        }
    }
    ll find(const string& s) {
        int i = 0;
        int sum = 0;
        for (char c : s) {
            c -= 'a';
            if (nodes[i].next[c] == 0) {
                return 0;
            }
            i = nodes[i].next[c];
            sum += nodes[i].cnt;
        }
        return sum;
    }
};
struct Treea {//1-idx
    int n;vl tree;
    Treea(int size) {
        n = size;tree.assign(n + 1, 0);
    }
    void update(int i, ll t) {
        while (i <= n) {
            tree[i] += t;
            i += i & (-i);
        }
    }
    ll sum(int i) {
        ll sum = 0;
        while (i > 0) {
            sum += tree[i];
            i -= i & (-i);
        }
        return sum;
    }
};
struct ST {//1-idx,(max,min,gcd,lcm,&,|,minidx,maxidx)
    int n;vvi st;vi log;
    ST(const vi& v) {
        n = v.size() - 1;
        int maxlog = 20;
        st.assign(n + 1, vi(maxlog + 1));
        log.assign(n + 2, 0);
        for (int i = 2; i <= n; i++) {
            log[i] = log[i >> 1] + 1;
        }
        for (int i = 1; i <= n; i++) {
            st[i][0] = v[i];
        }
        for (int j = 1; j <= maxlog; j++) {
            for (int i = 1; i + (1 << j) - 1 <= n; i++) {
                st[i][j] = max(st[i][j-1], st[i + (1 << (j-1))][j-1]);
            }
        }
    }
    int query(int l, int r) {
        int j = log[r - l + 1];
        return max(st[l][j], st[r - (1 << j) + 1][j]);
    }
};
struct SegTree {//1-idx,(sum,max,min,gcd,lcm,乘积,|,&,^)
    int n;
    vl tree, lazy;
    SegTree(int size) {
        n = size;
        tree.assign(4 * n, 0);
        lazy.assign(4 * n, 0);
    }
    void push(int v, int l, int r) {
        if (lazy[v] != 0) {
            tree[v] += lazy[v];
            if (l != r) {
                lazy[v*2] += lazy[v];
                lazy[v*2+1] += lazy[v];
            }
            lazy[v] = 0;
        }
    }
    void update(int v, int l, int r, int ul, int ur, ll val) {
        push(v, l, r);
        if (ul > r || ur < l) return;
        if (ul <= l && r <= ur) {
            lazy[v] += val;
            push(v, l, r);
            return;
        }
        int mid = (l + r) / 2;
        update(v*2, l, mid, ul, ur, val);
        update(v*2+1, mid+1, r, ul, ur, val);
        tree[v] = max(tree[v*2], tree[v*2+1]);
    }
    ll query(int v, int l, int r, int ql, int qr) {
        push(v, l, r);
        if (ql > r || qr < l) return LLONG_MIN;
        if (ql <= l && r <= qr) return tree[v];
        int mid = (l + r) / 2;
        return max(query(v*2, l, mid, ql, qr), query(v*2+1, mid+1, r, ql, qr));
    }
    void update(int l, int r, ll val) {
        update(1, 1, n, l, r, val);
    }
    ll query(int l, int r) {
        return query(1, 1, n, l, r);
    }
};
void solve() {
    //cout << "---------------" << endl;
   
}
/*
*/
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);cout.tie(nullptr);
    //initny(MAXN);
    //initjc(MAXN);
    //initp(MAXN);
    go(solve);
    //solve();
    return 0;
}
基础
int*a=new int(n) delete[] a动态数组
memset（位置，指定元素，sizeof（数组））初始化数组为指定元素
获取数组大小size()内存sizeof()
&按位与运算 |按位或运算 ^按位异或运算 ~取反运算 ^32大小写转化
stol("FF", nullptr, 16)2到36进制转化10进制
函数传引用&不会再拷贝一次
1e7 int数据大概47mb
树状数组下标离散化，map和二分查找
__builtin_popcount(i); // 计算二进制1的个数
除法向上取整（x+y-1）/y
滑窗越长越合法ans += left，越短越合法ans += right - left + 1，恰好型f(k) - f(k + 1)
排序置换环 并查集解
01bfs用双端队列，0开头入队，1末尾入队
三色标记法 未遍历0 遍历中1 遍历完2
拓扑排序dfs倒序，bfs正序
最短路d朴素算法 初始化两点距离g和单点最短路数组dist，找当前点连接的最短距离的点，标记访问过，更新dist数组
堆优化版，带距离邻接表g加优先队列
最短路Floyd算法，二维数组存边的距离，无边赋最大值。三维数组递推
f[k + 1][i][j] = Math.min(f[k][i][j], f[k][i][k] + f[k][k][j]);可以优化成二维
最小生成树k算法，按权值升序，如果两点祖先不同合并答案加权值
最小生成树prim算法，带距离邻接表g加优先队列
0.5*|(( x₁y₂ + x₂y₃ + ... + xₙ₋₁yₙ + xₙy₁ ) - ( y₁x₂ + y₂x₃ + ... + yₙ₋₁xₙ + yₙx₁ ))|多边形面积公式
枚举右维护左 枚举中间前后缀分解
排序不等式贪心最大最小
单调栈求下一个更大更小 单调队列求区间最大最小
01bfs双端队列实现 01花费（传送门）
自定义排序
sort(a.begin(), a.end()); // 升序
sort(a.begin(), a.end(), greater<>()); // 降序
sort(v.begin(), v.end(), [](auto &a, auto &b) {
    return a.second < b.second; // 按照 second 升序
});lambda表达式写法
bool cmp(pair<int, int> a, pair<int, int> b) {return a.first < b.first;}
sort(v.begin(), v.end(), cmp);自定义比较函数
优先队列自定义排序
struct cmp {
    bool operator()(int a, int b) {
        return a > b;
        }
    };
    priority_queue<int, vi, cmp> pq;
    auto cmp = [](int a, int b) { return a > b; };
    priority_queue<int, vi, decltype(cmp)> pq(cmp);
    priority_queue<int, vi, greater<int>> pq;
最小堆priority_queue<int, vi, greater<int>> pq;
cmath
abs fabs sqrt cbrt pow(x,y) exp自然对数的指数函数 log log2 log10 ceil向上取整 floor向下取整 round四舍五入 trunc截断小数 fmod浮点取余 hypot勾股 nearbyint返回最接近的整数 sin cos tan
集合通用方法
stable_sort稳定排序
fill(arr.begin(), arr.end(), 0);填充
equal(arr1.begin(), arr1.end(), arr2.begin());判等
binary_search(arr.begin(), arr.end(), 5);二分
for (int& i : nums)可修改加强for循环
reverse(nums.begin(), nums.end())反转
count(元素)：返回容器中指定元素的出现次数。
clear()：清空容器中的所有元素。
size()：返回容器中的元素个数。
empty()：判断容器是否为空，返回布尔值。
begin()：返回指向第一个元素的迭代器。end()：返回指向最后一个元素之后位置的迭代器。
rbegin()：返回指向最后一个元素的反向迭代器。rend()：返回指向第一个元素之前的反向迭代器。
find(元素)：查找指定元素，返回迭代器指向该元素的位置。
swap(另一个vector)：交换两个 vector 的内容。可以用来清空
unique(迭代器，迭代器)相邻重复元素移到末尾，返回去重后结尾迭代器
merge(1begin，1end，2begin，2end，back_inserter3)两个有序序列有序合并到第三个序列的插入迭代器
inplace_merge(begin，begin+middle，end)范围原地合并成有序序列
next_permutatin(begin，end)全排列更改为下一个排列
最后一个返回false并变回第一个，否则返回true
prev_permutation上一个全排列
STL
vector动态数组
vector<int> vec;vector<int> vec(n);vector<int> vec(n, val);vector<int> vec = {1, 2, 3};vector<int> vec2(vec1);
vector<vector<int>> ans(n, vector<int>(m, 0)); // 创建二维动态数组 n x m
push_back(value);                          // 在末尾添加元素
insert(pos, value);                        // 在指定位置插入元素
insert(pos, count, value);                 // 在指定位置插入 count 个相同元素
pop_back();                                // 删除最后一个元素
erase(pos);                                // 删除指定位置元素
clear();                                   // 清空整个 vector
vec[index];                                // 返回指定索引的元素
vec.at(index);                             // 返回指定索引元素，越界会抛异常
front();                                   // 返回第一个元素
back();                                    // 返回最后一个元素
assign(n, value);                          // 将容器的所有元素赋值为 value，大小为 n
list双向链表
push_back(value);        // 在列表末尾添加元素
push_front(value);       // 在列表开头添加元素
assign(count, value);    // 用 count 个 value 替换当前列表
pop_back();              // 删除最后一个元素
pop_front();             // 删除第一个元素
remove(value);           // 删除所有等于 value 的元素
reverse(a.);               // 翻转列表
auto it = find(all(a), mx);a.erase(it);//删除指定元素

set集合（红黑树映射）multiset重复集合 unordered_set哈希集合
s.insert(value);           // 将元素插入集合（multiset 可重复，set 不重复）
s.erase(value);            // 根据值删除元素（set 删除最多 1 个，multiset 删除所有相等元素）
s.find(value);             // 查找指定值，返回迭代器，找不到返回 end()
s.count(value);            // 返回集合中等于 value 的元素数量
s.lower_bound(value);      // 返回第一个 >= value 的迭代器
s.upper_bound(value);      // 返回第一个 > value 的迭代器
s.equal_range(value);      // 返回 [lower_bound, upper_bound) 迭代器对（多用于 multiset）
*s.begin();                // 获取集合中的最小元素
*s.rbegin();               // 获取集合中的最大元素

map映射（红黑树映射）multimap重复映射 unordered_map哈希映射
mp.insert({key, value});      // 插入键值对
mp[key];                      // 访问或修改 map 中的值（仅 map 支持）
mp.at(key);                    // 访问 map 中的值，不存在会抛异常
mp.find(key);                  // 返回指向指定键的迭代器，找不到返回 end()
mp.count(key);                 // 返回 map 中指定键的数量（map 0 或 1，multimap 可 >1）
mp.lower_bound(key);           // 返回第一个 >= key 的迭代器
mp.upper_bound(key);           // 返回第一个 > key 的迭代器
mp.equal_range(key);           // 返回 [lower_bound, upper_bound) 迭代器对（多用于 multimap）
mp.erase(key);                 // 按键删除元素，返回删除数量
mp.begin()->first;             // 获取最小 key
mp.rbegin()->first;            // 获取最大 key

stack栈
push(element)：将元素压入栈顶。
pop()：移除栈顶元素，但不返回其值。
top()：返回栈顶元素的引用，但不移除它。
queue队列
push(element)：将元素添加到队列的尾部。
pop()：移除队列的第一个元素，但不返回其值
front()：返回队列第一个元素的引用，但不移除它。
back()：返回队列最后一个元素的引用，但不移除它。

deque双端队列
push_front()头部插入
pop_front()删除头部
push_back()尾部插入
pop_back()删除尾部
front()：返回对双端队列第一个元素的引用。
back()：返回队列最后一个元素的引用，但不移除它。
[]随机访问
priority_queue优先队列
priority_queue<int> maxHeap;最大堆
priority_queue<int,ci, greater<int>> minHeap;最小堆
push(element)：将元素添加到优先队列中。
top()：返回优先队列顶部元素的引用，但不移除它。
pop()：移除优先队列顶部的元素。

c风格字符串
strlen()长度 strcmp()比较 strncmp()比较前n个
strcpy_s（）复制字符串 strncpy_s（）指定最大字符数
strcat_s（）字符串拼接 strncat_s（）指定最大字符数
strchr（）查找字符首次出现 strrchr（）查找字符最后一次出现
strstr（）查找字符串首次出现
atoi（）字符串转int

string字符串
初始化string s;string s("Hello, world!");
memset（字符串，0，sizeof（字符串））初始化字符串
s[] at()访问
size() length()获取长度
append() += 末尾追加字符串
find()：查找子串或字符首次出现的位置。
substr()：根据位置和长度提取子串。
replace()：替换字符串中的某个部分为另一段字符串。
insert()：某个位置插入字符串
erase()：删除字符串的一部分
reverse()反转
 toupper(c); // 转换为大写 tolower(c); // 转换为小写
compare()：比较两个字符串。相等=0
compare(初始位置, 长度, str2);指定范围子串比较
substr(初始位置，长度)截取子串
s.find("abc")从头查找 "abc"，返回起始索引，找不到返回 string::npos
s.rfind("abc")从后往前查找
s.find_first_of("abc")查找第一个出现在 "abc" 中的字符
s.find_last_of("abc")查找最后一个出现在 "abc" 中的字符
s.find_first_not_of("abc")查找第一个不在 "abc" 中的字符
s.find_last_not_of("abc")查找最后一个不在 "abc" 中的字符
stoi(s) string转int to_string(int) int转string

bitset
bitset<32> b;bitset<8> b(15);bitset<8> b("10101010");
b[i]            // 访问第 i 位（从右往左，0-indexed）
b.set()         // 所有位设为 1
b.set(i)        // 第 i 位设为 1
b.set(i, 0)     // 第 i 位设为 0
b.reset()       // 所有位设为 0
b.reset(i)      // 第 i 位设为 0
b.flip()        // 所有位翻转
b.flip(i)       // 第 i 位翻转
b.count()       // 返回 1 的个数（非常快）
b.size()        // 返回位数 N
b.any()         // 是否至少有一个 1
b.none()        // 是否全为 0
b.all()         // 是否全为 1
b.to_ullong()   // 转为 unsigned long long
b.to_string()   // 转为字符串

集合枚举
for (int i = 0; i < (1 << l); i++)
    for (int j = 0; j < l; j++)
        if (i >> j & 1)
二维差分（不需要显式初始化）
void insert(int x1, int y1, int x2, int y2, int c) {
    a[x1][y1] += c;
    a[x2 + 1][y1] -= c;
    a[x1][y2 + 1] -= c;
    a[x2 + 1][y2 + 1] += c;
}
for (int i = 1; i <= n; ++i)
    for (int j = 1; j <= m; ++j)
        a[i][j] += a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1];//前缀和复原差分数组
埃氏筛法
vector<bool> p(N + 1, true);
for (int i = 2; i * i <= N; i++) {
    if (p[i]) {
        for (int j = i * i; j <= N; j += i) {
            p[j] = false;
        }}}
组合数(杨辉三角)
for (int i = 1; i <= n; i++)
    for (int j = i; j >= 1; j--)
        a[j] += a[j - 1];
错排
cp[0] = 1; cp[1] = 0;
for (int i = 2; i <= n; i++)
    cp[i] = (i - 1) * (cp[i - 1] + cp[i - 2]);
并查集按秩合并
int find(vi &root, int x){
    if(root[x]!=x) root[x] = find(root, root[x]);
    return root[x];
}
void unite(vi &root, vi &rank, int x,int y){
    x=find(root,x); y=find(root,y);
    if(x==y) return;
    if(rank[x]<rank[y]) swap(x,y);
    root[y]=x;
    if(rank[x]==rank[y]) rank[x]++;
}
区间dp
for (int len = 2; len <= n; len++) {
    for (int i = 1; i + len - 1 <= n; i++) {
        int j = i + len - 1;
        for (int k = i; k < j; k++) {
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + cost(i, k, j));}}}
01背包
for (int i = 1; i <= n; i++)
    for (int j = m; j >= w[i]; j--)
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
完全背包
for (int i = 1; i <= n; i++)
    for (int j = w[i]; j <= m; j++)
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
多重背包
for (int i = 1; i <= n; i++)
    for (int j = m; j >= w[i]; j--)
        for (int k = 1; k <= s[i] && k * w[i] <= j; k++)
            dp[j] = max(dp[j], dp[j - k * w[i]] + k * v[i]);
二维费用背包
for (int i = 1; i <= n; i++)
    for (int j = v; j >= v1[i]; j--)
        for (int k = m; k >= m1[i]; k--)
            dp[j][k] = max(dp[j][k], dp[j - v1[i]][k - m1[i]] + w1[i]);
分组背包
for (int i = 1; i <= n; i++)
    for (int j = m; j >= 0; j--)
        for (int k = 1; k <= s[i]; k++)
            if (j >= w[i][k])dp[j] = max(dp[j], dp[j - w[i][k]] + v[i][k]);
最短路 Dijkstra
vector<vpii> g(n + 1);
vi dist(n + 1, INT_MAX);
priority_queue<pii, vpii, greater<>> pq;
dist[start] = 0;
pq.push({ 0, start });
while (!pq.empty()) {
    pii t = pq.top(); pq.pop();
    int d = t.first;
    int u = t.second;
    if (d > dist[u]) continue;
    for (pii& edge : g[u]) {
        int v = edge.first;
        int w = edge.second;
        if (dist[v] > dist[u] + w) {
            dist[v] = dist[u] + w;
            pq.push({ dist[v], v });}}}
最小生成树 Kruskal
vvi edges;
vi root;
root.assign(n + 1, 0);
for (int i = 0; i <= n; i++) root[i] = i;
sort(all(edges), [](const vi& a, const vi& b) {
    return a[2] < b[2];
    });
ll total = 0;
for (vi& e : edges) {
    int u = e[0], v = e[1], w = e[2];
    int x= find(u), y = find(v);
    if (x != y) {
        total += w;
        root[x] = y;}}
求约数个数 唯一分解定理
int yscount(int x) {
    int sum = 1;
    while (x > 1) {
        int p = minp[x];
        int t= 0;
        while (minp[x] == p) {
            t++;x /= p;
        }
        sum *= (t + 1);
    }
    return sum;
}
线段树
struct SegTree {
    int n;
    vl tree, lazy;
    SegTree(int size) {
        n = size;
        tree.assign(4 * n, 0);
        lazy.assign(4 * n, 0);
        // 初始化建议：sum: 0 max: -INF min: INF gcd: 0 lcm: 1? 乘积: 1   |, &, ^: 0
    }
    void push(int v, int l, int r) {
        if (lazy[v] == 0) return;  // 懒标记为0，不操作
        // =============== 根据操作选择下面的 push ===============
        // 1. 区间加：sum, max, min 用
        tree[v] += lazy[v] * (r - l + 1);  // sum: 乘长度
        // tree[v] += lazy[v];             // max/min: 不乘长度
        // gcd, lcm, 乘积, &, |, ^ 不能用“区间加”懒标记！
        // 如果是“区间 or”：tree[v] |= lazy[v];
        // 如果是“区间 and”：tree[v] &= lazy[v];
        // 如果是“区间 xor”：tree[v] ^= lazy[v];
        // 如果是“区间乘”：tree[v] = (tree[v] * lazy[v]) % MOD;
        if (l != r) {
            lazy[v*2]   += lazy[v];   // sum, max, min
            lazy[v*2+1] += lazy[v];   // sum, max, min
            // lazy[v*2]   |= lazy[v]; // 区间 or
            // lazy[v*2+1] |= lazy[v];
            // lazy[v*2]   &= lazy[v]; // 区间 and
            // lazy[v*2+1] &= lazy[v];
            // lazy[v*2]   ^= lazy[v]; // 区间 xor
            // lazy[v*2+1] ^= lazy[v];
            // lazy[v*2]   *= lazy[v]; // 区间乘，需 mod
            // lazy[v*2+1] *= lazy[v];
        }
        lazy[v] = 0;
    }
    void update(int v, int l, int r, int ul, int ur, ll val) {
        push(v, l, r);
        if (ul > r || ur < l) return;
        if (ul <= l && r <= ur) {
            // =============== 懒标记赋值 ===============
            lazy[v] += val;   // sum, max, min: 区间加
            // lazy[v] |= val; // 区间 or
            // lazy[v] &= val; // 区间 and
            // lazy[v] ^= val; // 区间 xor
            // lazy[v] *= val; // 区间乘
            push(v, l, r);
            return;
        }
        int mid = (l + r) / 2;
        update(v*2,   l,     mid, ul, ur, val);
        update(v*2+1, mid+1, r,   ul, ur, val);
        // ====== 合并子节点 (tree[v] = merge(left, right)) =====
        tree[v] = tree[v*2] + tree[v*2+1];           // sum
        // tree[v] = max(tree[v*2], tree[v*2+1]);     // max
        // tree[v] = min(tree[v*2], tree[v*2+1]);     // min
        // tree[v] = gcd(tree[v*2], tree[v*2+1]);     // gcd (不能用区间加!)
        // tree[v] = lcm(tree[v*2], tree[v*2+1]);     // lcm (不能用区间加!)
        // tree[v] = (tree[v*2] * tree[v*2+1]) % MOD; // 乘积 (不能用区间加!)
        // tree[v] = tree[v*2] | tree[v*2+1];         // |
        // tree[v] = tree[v*2] & tree[v*2+1];         // &
        // tree[v] = tree[v*2] ^ tree[v*2+1];         // ^
    }
    ll query(int v, int l, int r, int ql, int qr) {
        push(v, l, r);
        if (ql > r || qr < l) {
            // =============== 返回单位元 ===============
            return 0;                    // sum, |, ^
            // return 0;                 // gcd (数学上可接受)
            // return 1;                 // 乘积, lcm
            // return LLONG_MIN;         // max
            // return LLONG_MAX;         // min
            // return (1LL << 60) - 1;   // & (全1，近似)
        }
        if (ql <= l && r <= qr) return tree[v];
        int mid = (l + r) / 2;
        ll left  = query(v*2,   l,     mid, ql, qr);
        ll right = query(v*2+1, mid+1, r,   ql, qr);
        // =============== 合并查询结果 ===============
        return left + right;             // sum
        // return max(left, right);      // max
        // return min(left, right);      // min
        // return gcd(left, right);      // gcd
        // return lcm(left, right);      // lcm
        // return (left * right) % MOD;  // 乘积
        // return left | right;          // |
        // return left & right;          // &
        // return left ^ right;          // ^
    }
    void update(int l, int r, ll val) {
        update(1, 1, n, l, r, val);
    }
    ll query(int l, int r) {
        return query(1, 1, n, l, r);
    }
};
